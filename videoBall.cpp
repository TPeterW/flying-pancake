/*
 * Joey Button
 * Felix Wang
 * Peter Wang
 */

#include <stdio.h>
#include <opencv2/video/background_segm.hpp>
#include "opencv2/opencv.hpp"
#include "physics.h"

using namespace cv;
using namespace std;

#define RADIUS 32
#define THRESH 240.0f

const char *win = "video";


void drawCircle(Mat img, Point center, int radius)
{
    int thickness = -1;
    int lineType = 8;

    circle( img,
            center,
            radius,
            Scalar( 255, 255, 255 ),
            thickness,
            lineType);
}

void calcDir(Point *momentum, Point *pt, int height, int width) {
      pt->x += momentum->x;
      pt->y += momentum->y;

      if (pt->y < height) {
           // Accelerate due to Gravity
          momentum->y += 3;
      } else {
          //Bounce on the bottom
          momentum->x = momentum->x * 0.9;
          momentum->y = -(momentum->y * .6);   // bounce back up and halt it
          pt->y = height;
      }

      // off the top
      if (pt->y < RADIUS) {
            pt->y = RADIUS;
            momentum->y = -(momentum->y * .6);
            momentum->x = momentum->x * .9;
      }
      //Bounce on the Right
      if (pt->x > width) {
            pt->x=width;
            momentum->x = -(momentum->x * .6);
            momentum->y = momentum->y * .9;
      }
      //Bounce on the Left
      if (pt->x < RADIUS) {
            pt->x=RADIUS;
            momentum->x = -(momentum->x * .6);
            momentum->y = momentum->y * .9;
      }
      //Slow to stop if low momentum
      if (momentum->y * momentum->y <= 25 && pt->y == height){
          momentum->y = momentum->y / (2);
          momentum->x = momentum->x / (2);
      }

}

double getOverlap(Mat *ballFrame, Mat *handFrame, Point *center)
{
    // ballFrame->release();
    drawCircle(*ballFrame, *center, RADIUS / 2);
    // imshow(win, *ballFrame);
    // waitKey(50000);
    
    bitwise_and(*ballFrame, *handFrame, *ballFrame);
    
    return sum(*ballFrame)[0] / 255;
}

int main(void)
{   
    // hello();
    int cam = 0; // default camera
    VideoCapture cap(cam);
    if (!cap.isOpened()) {
        fprintf(stderr, "cannot open camera %d\n", cam);
        exit(1);
    }
    
    namedWindow(win, CV_WINDOW_AUTOSIZE);
    
    Mat fgMaskMOG;          // foreground mask generated by MOG method
    Mat inputFrame, outFrame;
    Mat circ;
    Point pt;               // center of the ball

    BackgroundSubtractorMOG2 MOG;

    pt.x = 500;
    pt.y = 0;

    Point momentum;
    momentum.x = 100;
    momentum.y = 100;

    cap >> inputFrame;
    cvtColor(inputFrame, outFrame, CV_LOAD_IMAGE_COLOR);
    cvtColor(inputFrame, circ, CV_BGR2GRAY);

    int height = inputFrame.rows - 2 * RADIUS;
    int width = inputFrame.cols - 2 * RADIUS;

    // double overlap;
    int count = 0;
    int sum;
    Point small;
    Mat ballFrame, handFrame;
    Mat foregroundMask, backgroundMask;
    while (++count) {
        cap >> inputFrame;

        calcDir(&momentum, &pt, height, width);

        MOG(inputFrame, fgMaskMOG);
        
        // blank canvas
        circ.setTo(Scalar(0,0,0));
        
        Rect ballRegion(pt.x, pt.y, 2 * RADIUS, 2 * RADIUS);
        ballFrame = circ(ballRegion);
        
        foregroundMask = fgMaskMOG > THRESH;         // have to put here otherwise floating point exception
        backgroundMask = fgMaskMOG <= THRESH;
        fgMaskMOG.setTo(Scalar(255, 255, 255), foregroundMask);     // clean up
        fgMaskMOG.setTo(Scalar(0, 0, 0), backgroundMask);
        handFrame = fgMaskMOG(ballRegion);                          // cut to small size
        
        // top left
        int halfRad = RADIUS / 2;
        small.x = halfRad;    small.y = halfRad;
        sum = getOverlap(&ballFrame, &handFrame, &small);
        momentum.x += sum;              momentum.y += sum;
        
        // top right
        small.x = 3 * halfRad;   small.y = halfRad;
        sum = getOverlap(&ballFrame, &handFrame, &small);
        momentum.x -= sum;              momentum.y += sum;
        
        
        // bottom left
        small.x = halfRad;    small.y = 3 * halfRad;
        sum = getOverlap(&ballFrame, &handFrame, &small);
        momentum.x += sum;              momentum.y -= sum;
        
        // bottom right
        small.x = 3 * halfRad;   small.y = 3 * halfRad;
        sum = getOverlap(&ballFrame, &handFrame, &small);
        momentum.x -= sum;              momentum.y -= sum; 
        
        
        // bitwise_and(circ, fgMaskMOG, circ); // THIS IS FOR CALCULATING INTERSECTION
        // anything white, in circ, is intersecting the ball to be drawn --
        // Change the momentum here
        // Clever
        
        // overlap = sum(circ)[0];
        // if (overlap > 10000.0)
        //   momentum.y -= 10;

        // EVERYTHING ABOVE THIS SHOULD BE CALCULATING WHERE TO DRAW
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        // EVERYTHING BELOW THIS LINE SHOULD BE DRAWING THE outFrame
        outFrame.setTo(Scalar(0,0,0));      // set all of outFrame to be black
        outFrame.setTo(Scalar(255, 255, 255), foregroundMask);
        
        drawCircle(outFrame, pt, RADIUS);
        
        imshow(win, outFrame);

        if (waitKey(1) >= 0)        // listening for key press
	        break;
    }

    return 0;
}

/*
    Mat BGRChannels[3];
    split(outFrame,BGRChannels); // split the BGR channesl
    BGRChannels[1]=Mat::zeros(outFrame.rows,outFrame.cols,CV_8UC1);// removing Green channel
    merge(BGRChannels,3,outFrame); // pack the image

    waitKey(0);
*/
